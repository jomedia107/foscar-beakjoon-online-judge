
# 문제의 목적은 여러가지 염기서열들 중에 각자리별로 최다 빈도를 갖는 문자를 선정하여 
# 하나의 대표 염기서열을 선정하는데에 있다. 
# 그 방법으로 최다 빈도 문자를 제외한 문자들의 갯수의 최솟값(hap변수에 추가)을 찾는 것을 선택했다. 

#시간복잡도를 계산하였을 떄 N의 범위를 최대 1000으로 잡을 수 있기 떄문에
# O(N^2)의 시간 복잡도로 설계하였을 때 1초이내에 실행된다고 할 수 있다. 

n,m = map(int, input().split()) #m개의 문자로 이뤄진 묶음을 n묶음 만들겠다.

arr=[]

result = ''

for i in range(n):
    arr.append(list(map(str,input()))) #m개의 문자들을 문자형으로 리스트로 n묶음 추가한다. 2차원 리스트

hap = 0 #최빈 문자를 제외한 다른 문자의 빈도수 합

for i in range(m):
    a,c,g,t =0,0,0,0
    #같은 m값에 대해 다른 DNA들을 검사하는 것이므로, 이차원 리스트 상의 첫번째 열을 검사한다. 
    for j in range(n): #만약 j가 1이고 m도 1일 때 
        if arr[j][i] =='T': # 1행 1열의 문자검사 //다음 for문에서는 2행 1열의 문자 검사//다음 for문에서는 3행 1열의 문자 검사
            t +=1 #맞으면 1추가
        elif arr[j][i] == 'A':
            a += 1
        elif arr[j][i] == 'C':
            c += 1
        elif arr[j][i] == 'G':
            g += 1
    
    #위의 for문이 끝나면 행렬(2차원 리스트)의 한열에 대해서 문자의 갯수파악이 완료된다. (소문자 변수 a,c,g,t에 저장됨)
    #일단 만약 1열에 대한 문자파악이 완료되었다 치면
    if max(a,g,t,c) ==a: # 1열에 대해서 어떤 문자가 가장 많이 나왔는지 파악하고 
        result += 'A' #가장 많이 나온 문자에 대해 최종 DNA 서열에 추가시킨다.(최종 염기서열의 1열(첫번째 문자 획득))
        hap += g+t+c # 최빈 문자를 제외한 나머지 문자들의 빈도수를 hap이라는 변수에 저장한다.
    elif max(a,g,t,c) ==c:
        result += 'C'
        hap += a+g+t
    elif max(a,g,t,c) ==g:
        result += 'G'
        hap += a+t+c
    elif max(a,g,t,c) ==t:
        result += 'T'
        hap += a+g+c
# 안쪽 for문은 통해 1개의 세로줄씩 검사가 끝나고,
#가장 바깥 for문이 실행되었을 때 비로소 모든 열에 대한 검사가 끝나게 된다. 

print(result)# 최종적으로 각 열마다의 최빈 문자열의 결과를 하나의 염기서열로 보여준다.
print(hap)# 최솟값을 연산한다.
